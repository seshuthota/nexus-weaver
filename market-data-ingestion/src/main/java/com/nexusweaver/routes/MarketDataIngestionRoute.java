package com.nexusweaver.routes;

import com.nexusweaver.model.MarketDataEvent;
import com.nexusweaver.processors.MarketDataProcessor;
import com.nexusweaver.processors.MessageValidator;
import lombok.extern.slf4j.Slf4j;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.model.dataformat.JsonLibrary;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

/**
 * Market Data Ingestion Route
 * 
 * Handles multiple data sources with proper clustering:
 * - Timer-based simulated market data (CLUSTERED - only one instance active)
 * - Direct processing pipeline (all instances process)
 * - WebSocket feeds (CLUSTERED - only one instance connects)
 * - TCP feeds (CLUSTERED - only one instance connects)
 */
@Slf4j
@Component
public class MarketDataIngestionRoute extends RouteBuilder {

    @Autowired
    private MarketDataProcessor marketDataProcessor;

    @Autowired
    private MessageValidator messageValidator;

    @Override
    public void configure() throws Exception {
        
        // Error handling
        onException(Exception.class)
            .handled(true)
            .log("Error processing market data: ${exception.message}")
            .to("micrometer:counter:market.data.errors");

        // ========================================================================================
        // CLUSTERED ROUTES - Only ONE instance across the cluster will run these
        // ========================================================================================
        
        // CLUSTERED: Market data generator (only one pod generates data)
        from("master:market-data-cluster:timer:market-data-generator?period=10000")
            .routeId("market-data-generator-clustered")
            .log("üèÜ MASTER INSTANCE: Generating sample market data on pod ${env:HOSTNAME}")
            .process(exchange -> {
                MarketDataEvent event = MarketDataEvent.createSample();
                exchange.getIn().setBody(event);
                exchange.getIn().setHeader("source", "SIMULATOR");
                exchange.getIn().setHeader("symbol", event.getSymbol());
                exchange.getIn().setHeader("generatingPod", System.getenv("HOSTNAME"));
            })
            .to("direct:process-market-data");

        // CLUSTERED: FIX Protocol ingestion (only one pod connects to FIX gateway)
        from("master:fix-cluster:mina:tcp://{{fix.gateway.host:localhost}}:{{fix.gateway.port:9878}}?codec=#fixCodec&sync=false")
            .routeId("fix-ingestion-clustered")
            .log("üèÜ MASTER INSTANCE: Received FIX message on pod ${env:HOSTNAME}")
            .process(exchange -> {
                // FIX message processing
                exchange.getIn().setHeader("source", "FIX");
                exchange.getIn().setHeader("receivingPod", System.getenv("HOSTNAME"));
            })
            .to("direct:process-market-data");

        // CLUSTERED: HTTP REST endpoint (only one pod listens)
        from("master:rest-cluster:netty-http:http://0.0.0.0:8082/market-data?httpMethodRestrict=POST")
            .routeId("rest-market-data-clustered")
            .log("üèÜ MASTER INSTANCE: Received REST market data on pod ${env:HOSTNAME}")
            .unmarshal().json(JsonLibrary.Jackson)
            .process(exchange -> {
                exchange.getIn().setHeader("source", "REST_API");
                exchange.getIn().setHeader("receivingPod", System.getenv("HOSTNAME"));
            })
            .to("direct:process-market-data");

        // ========================================================================================
        // DISTRIBUTED ROUTES - ALL instances can process these
        // ========================================================================================

        // Main processing pipeline (all pods can process)
        from("direct:process-market-data")
            .routeId("market-data-processor")
            .log("üìä PROCESSING: Market data from ${header.source} on pod ${env:HOSTNAME} (generated by ${header.generatingPod})")
            
            // Validate message
            .process(messageValidator)
            
            // Add processing metadata
            .process(exchange -> {
                MarketDataEvent event = exchange.getIn().getBody(MarketDataEvent.class);
                exchange.getIn().setHeader("symbol", event.getSymbol());
                exchange.getIn().setHeader("exchange", event.getExchange());
                exchange.getIn().setHeader("messageType", event.getMessageType());
                exchange.getIn().setHeader("timestamp", event.getTimestamp());
                exchange.getIn().setHeader("processingPod", System.getenv("HOSTNAME"));
            })
            
            // Process market data
            .process(marketDataProcessor)
            
            // Add metrics
            .to("micrometer:counter:market.data.processed.total?tags=source=${header.source},symbol=${header.symbol},pod=${env:HOSTNAME}")
            .to("micrometer:timer:market.data.processing.latency")
            
            // Route based on message type
            .choice()
                .when(header("messageType").isEqualTo("MARKET_DATA"))
                    .log("üîÑ ROUTING: Market data for ${header.symbol} processed by pod ${header.processingPod}")
                    .to("direct:market-data-output")
                .when(header("messageType").isEqualTo("TRADE"))
                    .log("üîÑ ROUTING: Trade data for ${header.symbol} processed by pod ${header.processingPod}")
                    .to("direct:trade-output")
                .otherwise()
                    .log("‚ùì UNKNOWN: Message type ${header.messageType} processed by pod ${header.processingPod}")
                    .to("direct:unknown-output")
            .end();

        // Output routes - all pods can publish (load balanced)
        from("direct:market-data-output")
            .routeId("market-data-output")
            .log("üì§ PUBLISHING: Market data Symbol=${header.symbol}, Price=${body.price}, Volume=${body.volume} from pod ${env:HOSTNAME}")
            .marshal().json(JsonLibrary.Jackson)
            .to("rabbitmq:market-prices-stream?hostname={{rabbitmq.hostname}}&port=5672&username={{rabbitmq.username}}&password={{rabbitmq.password}}&routingKey=market.data")
            .log("‚úÖ PUBLISHED: To RabbitMQ stream market-prices-stream from pod ${env:HOSTNAME}");

        from("direct:trade-output")
            .routeId("trade-output")
            .log("üì§ PUBLISHING: Trade data from pod ${env:HOSTNAME}")
            .marshal().json(JsonLibrary.Jackson)
            .to("rabbitmq:trade-executions-stream?hostname={{rabbitmq.hostname}}&port=5672&username={{rabbitmq.username}}&password={{rabbitmq.password}}&routingKey=trade.execution")
            .log("‚úÖ PUBLISHED: To RabbitMQ stream trade-executions-stream from pod ${env:HOSTNAME}");

        from("direct:unknown-output")
            .routeId("unknown-output")
            .log("‚ùì UNKNOWN: Data type processed by pod ${env:HOSTNAME}: ${body}")
            .to("log:unknown-output?level=WARN&showBody=true");
    }
} 